#define HUNTER_N		0
#define HUNTER_NE		1
#define HUNTER_E		2
#define HUNTER_SE		3
#define HUNTER_S		4
#define HUNTER_SW		5
#define HUNTER_W		6
#define HUNTER_NW		7

object monster_hunter : monster_base_simple {
	float		nextAttack;
	float		nextConsole;
	float		nextDamageReaction;
	float		nextVehicleAttack;
	float		nextGrenade;
	float		nextHealCheck;
	float		nextPlayerCheck;
	float		nextCover;
	float		nextCharge;
	float		nextAdjust;
	float		numGrenades;
	float		nextPain;
	float		nextLean;
	float		nextMove;
	float		nextManeuver;
	float		nextEliteManeuver;
	entity		cur_reaction;
	entity		node;
	entity		lastShootTarget;
	float		AI_DIR;
	float		scriptDir;
	boolean		sniper;
	boolean		can_snipe;
	float		last_dir;
	boolean		portal_attack;
	boolean		AI_DIR_MOVEMENT;
	boolean		AI_ENEMY_RUSH;
	boolean		AI_ENEMY_RETREAT;
	boolean		AI_ENEMY_HEALTH_LOW;
	boolean		AI_ENEMY_RESURRECTED;
	boolean		AI_ONGROUND;
	boolean		AI_ENEMY_SHOOTABLE;
	boolean		AI_LOOKOUT;
	boolean		AI_SHOTBLOCK;
	boolean		AI_BLOCKED_FAILSAFE;
	boolean		AI_KNOCKBACK;
	boolean		beenBound;
	boolean		beenInCombat;		//HUMANHEAD jsh PCF 5/2/06 hunter combat fixes
	float		AI_LAST_DAMAGE_TIME;
	boolean		AI_ALLOW_ORDERS;
	boolean		AI_LAST_ENEMY_VISIBLE;
	float		AI_ENEMY_LAST_SEEN;
	float		AI_NEXT_DIR_TIME;
	float		shots_left;
	boolean		elite;
	void		monster_begin();
	float		check_attacks();
	void		do_attack( float attack_flags );
	void		combat_range();
	void		combat_melee();
	boolean		combat_move();
	boolean		combat_cover();
	void		combat_snipe();
	void		combat_grenade();
	void		combat_charge();
	void		combat_vehicle();
	boolean		combat_dodge();
	void		combat_range_vehicle();
	void		combat_mandown( entity old_ally );
	boolean		combat_console();
	boolean		should_grenade();
	vector		find_cover();
	void		sight_enemy();
	void		init();
	void		check_dir();
	boolean		use_reaction();
	void		path_shootat();
	boolean		checkForEnemy( float use_fov );	//HUMANHEAD jsh PCF 5/2/06 hunter combat fixes

	void 		state_Killed();
};

void monster_hunter::Torso_Idle() {
	idleAnim( ANIMCHANNEL_TORSO, "alert_idle" );
	eachFrame {
		if ( AI_PAIN && sys.getTime() > nextPain ) {
			break;
		}
		waitFrame();
	}
	animState( ANIMCHANNEL_TORSO, "Torso_Pain", 0 );
}

void monster_hunter::Torso_Pain() {
	startSound( "snd_pain", SND_CHANNEL_VOICE, 0 );
	playAnim( ANIMCHANNEL_TORSO, getPainAnim() );
	while ( !animDone( ANIMCHANNEL_TORSO, 0 ) ) {
		waitFrame();
	}
	nextPain = sys.getTime() + 0.3;
	animState( ANIMCHANNEL_TORSO, "Torso_Idle", 3 );
}

void monster_hunter::Torso_MeleeAttack() {
	laserOff();
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 4 );
	playAnim( ANIMCHANNEL_TORSO, "melee_forward" );
	while( !animDone( ANIMCHANNEL_TORSO, 4 ) ) {
		waitFrame();
	}
	finishAction( "melee_attack" );
	animState( ANIMCHANNEL_TORSO, "Torso_Idle", 4 );
}

void monster_hunter::Torso_Snipe() {
	playAnim( ANIMCHANNEL_TORSO, "snipe_attack" );
	while( !animDone( ANIMCHANNEL_TORSO, 4 ) ) {
		waitFrame();
	}
	finishAction( "snipe" );
	animState( ANIMCHANNEL_TORSO, "Torso_Idle", 4 );
}

void monster_hunter::Torso_GrenadeAttack() {
	float end_time = sys.getTime() + 0.9;
	setAnimPrefix( "alert" );
	laserOff();
	lookAtEnemy( 100 );
	if ( elite ) {
		playAnim( ANIMCHANNEL_TORSO, "mine_attack" );
	} else {
		playAnim( ANIMCHANNEL_TORSO, "alt_attack" );
	}
	while ( sys.getTime() < end_time ) {
		waitFrame();
	}
	if ( numGrenades > 0 ) {
		numGrenades = numGrenades - 1;
	}
	finishAction( "grenade_attack" );
	animState( ANIMCHANNEL_TORSO, "Torso_Idle", 4 );
}

void monster_hunter::Torso_RangeAttackPain() {
	float i,end_time;
	startSound( "snd_pain", SND_CHANNEL_VOICE, 0 );
	playAnim( ANIMCHANNEL_TORSO, getPainAnim() );
	while ( !animDone( ANIMCHANNEL_TORSO, 4 ) ) {
		waitFrame();
	}
	nextPain = sys.getTime() + 0.2;
	setShaderParm(6, 1.0);
	for ( i=0;i<shots_left;i++ ) {
		if ( i == 0 ) {
			setBlendFrames( ANIMCHANNEL_TORSO, 4 );
		}
		playAnim( ANIMCHANNEL_TORSO, "alert_attack_idle" );
		end_time = sys.getTime() + 0.08 + 0.02 * sys.random(1.0);
		while ( !animDone( ANIMCHANNEL_TORSO, 8 ) ) {
			if ( end_time < sys.getTime() ) {
				break;
			}
			if ( AI_PAIN && sys.getTime() > nextPain ) {
				animState( ANIMCHANNEL_TORSO, "Torso_Pain", 4 );
			}
			waitFrame();
		}
	}
	end_time = sys.getTime() + 1;
	while ( end_time > sys.getTime() ) {
		if ( AI_PAIN && sys.getTime() > nextPain ) {
			animState( ANIMCHANNEL_TORSO, "Torso_Pain", 4 );
		}
		waitFrame();
	}
	setShaderParm(6, 0.0);
	animState( ANIMCHANNEL_TORSO, "Torso_Idle", 4 );
}

void monster_hunter::Torso_QuickShot() {
	AI_SHOTBLOCK = false;
	float i,end_time;
	lookAtEnemy( 5 );
	laserOff();
	setAnimPrefix( "alert" );
	setShaderParm(6, 1.0);
	startSound( "snd_prefire", SND_CHANNEL_BODY, 0 );
	playAnim( ANIMCHANNEL_TORSO, "alert_prefire" );
	for ( i=0;i<2;i++ ) {
		if ( !AI_PATHING && ( AI_SHOTBLOCK || !AI_ENEMY_VISIBLE ) ) {
			if ( !portal_attack ) {
				break;
			}
		}
		playAnim( ANIMCHANNEL_TORSO, "alert_attack_idle" );
		end_time = sys.getTime() + 0.08 + 0.04 * sys.random(1.0);
		while ( end_time > sys.getTime() ) {
			waitFrame();
		}
	}
	setShaderParm(6, 0.0);
	animState( ANIMCHANNEL_TORSO, "Torso_Idle", 4 );
}

void monster_hunter::Torso_RangeAttack() {
	AI_SHOTBLOCK = false;
	float i,end_time;
	lookAtEnemy( 5 );
	laserOff();
	setAnimPrefix( "alert" );
	setShaderParm(6, 1.0);
	end_time = sys.getTime() + 0.1;
	while ( end_time > sys.getTime() ) {
		waitFrame();
	}
	startSound( "snd_prefire", SND_CHANNEL_BODY, 0 );
	playAnim( ANIMCHANNEL_TORSO, "alert_prefire" );
	end_time = sys.getTime() + 0.5;
	while ( sys.getTime() < end_time ) {
		if ( AI_PAIN && sys.getTime() > nextPain ) {
			shots_left = 8;
			animState( ANIMCHANNEL_TORSO, "Torso_RangeAttackPain", 4 );
		}
		waitFrame();
	}
	for ( i=0;i<8;i++ ) {
		if ( !AI_PATHING && ( AI_SHOTBLOCK || !AI_ENEMY_VISIBLE ) ) {
			if ( !portal_attack ) {
				break;
			}
		}
		if ( i == 0 ) {
			playAnim( ANIMCHANNEL_TORSO, "alert_attack_first" );
		} else {
			playAnim( ANIMCHANNEL_TORSO, "alert_attack_idle" );
		}
		end_time = sys.getTime() + 0.08 + 0.04 * sys.random(1.0);
		while ( end_time > sys.getTime() ) {
			if ( AI_PAIN && sys.getTime() > nextPain ) {
				shots_left = 12 - i;
				animState( ANIMCHANNEL_TORSO, "Torso_RangeAttackPain", 4 );
			}
			waitFrame();
		}
	}
	end_time = sys.getTime() + 1;
	while ( end_time > sys.getTime() ) {
		if ( AI_PAIN && sys.getTime() > nextPain ) {
			setShaderParm(6, 0.0);
			animState( ANIMCHANNEL_TORSO, "Torso_Pain", 4 );
		}
		waitFrame();
	}
	sys.wait(1);
	setShaderParm(6, 0.0);
	animState( ANIMCHANNEL_TORSO, "Torso_Idle", 4 );
}

void monster_hunter::Torso_Fall() {
	playCycle( ANIMCHANNEL_TORSO, "jump_fall" );
	eachFrame {
		if ( !AI_FALLING ) {
			playAnim( ANIMCHANNEL_TORSO, "jump_land" );
			while ( !animDone( ANIMCHANNEL_TORSO, 4 ) ) {
				waitFrame();
			}
			animState( ANIMCHANNEL_TORSO, "Torso_Idle", 4 );
		}
	}
}

void monster_hunter::Torso_Bound() {
	beenBound = true;
	laserOff();
	overrideAnim( ANIMCHANNEL_LEGS );
	playCycle( ANIMCHANNEL_TORSO, "shuttle_bound" );
	eachFrame {
		if ( !AI_BOUND )			{ animState( ANIMCHANNEL_TORSO, "Torso_Idle",0 ); }
	}
}

void monster_hunter::Legs_Knockback() {
	overrideAnim( ANIMCHANNEL_TORSO );
	playAnim( ANIMCHANNEL_LEGS, "pain_knockback" );
	while ( !animDone( ANIMCHANNEL_LEGS, 4 ) ) {
		waitFrame();
	}
	enableAnim( ANIMCHANNEL_TORSO, 4 );
	finishAction( "knockback" );
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 8 );
}

void monster_hunter::Legs_Idle() {
	EnableWalkIK();
	idleAnim( ANIMCHANNEL_LEGS, "idle" );
	eachFrame {
		if ( AI_FORWARD )			{ animState( ANIMCHANNEL_LEGS, "Legs_Walk", 4 ); }
	}
}

void monster_hunter::Legs_LeanRight() {
	allowMovement( true );
	lookAtEnemy(10);
	DisableWalkIK();
	overrideAnim( ANIMCHANNEL_TORSO );
	playAnim( ANIMCHANNEL_LEGS, "cover_rlean" );
	while ( !animDone( ANIMCHANNEL_LEGS, 0 ) ) {
		waitFrame();
	}
	float i;
	boolean broke;
	for ( i=0;i<3;i++ ) {
		playAnim( ANIMCHANNEL_LEGS, "cover_rlean_fire" );
		while ( !animDone( ANIMCHANNEL_LEGS, 0 ) ) {
			if ( AI_SHOTBLOCK || AI_ENEMY_RUSH || enemyRange() < 200 ) {
				broke = true;
				break;
			}
			waitFrame();
		}
	}
	if ( !broke ) {
		playAnim( ANIMCHANNEL_LEGS, "cover_rlean_to_idle" );
		while ( !animDone( ANIMCHANNEL_LEGS, 0 ) ) {
			waitFrame();
		}
	}
	enableAnim( ANIMCHANNEL_TORSO, 12 );
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 12 );
}

void monster_hunter::Legs_LeanLeft() {
	allowMovement( true );
	lookAtEnemy(10);
	DisableWalkIK();
	overrideAnim( ANIMCHANNEL_TORSO );
	playAnim( ANIMCHANNEL_LEGS, "cover_llean" );
	while ( !animDone( ANIMCHANNEL_LEGS, 0 ) ) {
		waitFrame();
	}
	float i;
	boolean broke;
	for ( i=0;i<4;i++ ) {
		playAnim( ANIMCHANNEL_LEGS, "cover_llean_fire" );
		while ( !animDone( ANIMCHANNEL_LEGS, 0 ) ) {
			if ( AI_SHOTBLOCK || AI_ENEMY_RUSH || enemyRange() < 200 ) {
				broke = true;
				break;
			}
			waitFrame();
		}
	}
	if ( !broke ) {
		playAnim( ANIMCHANNEL_LEGS, "cover_llean_to_idle" );
		while ( !animDone( ANIMCHANNEL_LEGS, 0 ) ) {
			waitFrame();
		}
	}
	enableAnim( ANIMCHANNEL_TORSO, 12 );
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 12 );
}

void monster_hunter::Legs_JumpLeft() {
	overrideAnim( ANIMCHANNEL_TORSO );
	setBlendFrames( ANIMCHANNEL_TORSO, 0 );
	setBlendFrames( ANIMCHANNEL_LEGS, 0 );
	playAnim( ANIMCHANNEL_LEGS, "jump45l" );
	while( !animDone( ANIMCHANNEL_LEGS, 8 ) ) {
		waitFrame();
	}
	enableAnim( ANIMCHANNEL_TORSO, 4 );
	finishAction( "dive" );
}

void monster_hunter::Legs_JumpRight() {
	overrideAnim( ANIMCHANNEL_TORSO );
	setBlendFrames( ANIMCHANNEL_TORSO, 0 );
	setBlendFrames( ANIMCHANNEL_LEGS, 0 );
	playAnim( ANIMCHANNEL_LEGS, "jump45r" );
	while( !animDone( ANIMCHANNEL_LEGS, 8 ) ) {
		waitFrame();
	}
	enableAnim( ANIMCHANNEL_TORSO, 4 );
	finishAction( "dive" );
}

void monster_hunter::Legs_DiveLeft() {
	overrideAnim( ANIMCHANNEL_TORSO );
	playAnim( ANIMCHANNEL_LEGS, "alert_dive_left" );
	while( !animDone( ANIMCHANNEL_LEGS, 8 ) ) {
		waitFrame();
	}
	enableAnim( ANIMCHANNEL_TORSO, 4 );
	finishAction( "dive" );
}

void monster_hunter::Legs_DiveRight() {
	overrideAnim( ANIMCHANNEL_TORSO );
	playAnim( ANIMCHANNEL_LEGS, "alert_dive_right" );
	while( !animDone( ANIMCHANNEL_LEGS, 8 ) ) {
		waitFrame();
	}
	enableAnim( ANIMCHANNEL_TORSO, 4 );
	finishAction( "dive" );
}

void monster_hunter::Legs_Walk() {
	scriptDir = HUNTER_N;
	playCycle( ANIMCHANNEL_LEGS, "walk" );
	eachFrame {
		check_dir();
	}
}

void monster_hunter::Legs_Run() {
	EnableWalkIK();
	if ( !run ) {
		animState( ANIMCHANNEL_LEGS, "Legs_Walk", 2 );
	}
	scriptDir = HUNTER_N;
	playCycle( ANIMCHANNEL_LEGS, "run" );
	eachFrame {
		if ( AI_FORWARD ) {
			if ( !run ) { 
				animState( ANIMCHANNEL_LEGS, "Legs_Walk", 4 );
			}
		} else {
			animState( ANIMCHANNEL_LEGS, "Legs_Idle", 4 );
		}
	}
}

void monster_hunter::Legs_Backup() {
	scriptDir = HUNTER_S;
	playCycle( ANIMCHANNEL_LEGS, "alert_backup_slow" );
	eachFrame {
		check_dir();
	}
}

void monster_hunter::Legs_WalkLeft() {
	scriptDir = HUNTER_E;
	last_dir = HUNTER_E;
	playCycle( ANIMCHANNEL_LEGS, "strafe_left_slow" );
	eachFrame {
		check_dir();
	}
}

void monster_hunter::Legs_WalkRight() {
	scriptDir = HUNTER_W;
	last_dir = HUNTER_W;
	playCycle( ANIMCHANNEL_LEGS, "strafe_right_slow" );
	eachFrame {
		check_dir();
	}
}

void monster_hunter::Legs_Death() {
	stopAnim( ANIMCHANNEL_LEGS, 0 );
}

void monster_hunter::Legs_GravWander() {
	string anim;
	EnableWalkIK();
	eachFrame {
		if ( sys.random(100) < 50 ) {
			playAnim( ANIMCHANNEL_LEGS, "strafe_left" );
		} else {
			playAnim( ANIMCHANNEL_LEGS, "strafe_right" );
		}
		while( !animDone( ANIMCHANNEL_LEGS, 0 ) ) {
			if ( AI_BLOCKED ) {
				break;
			}
			waitFrame();
		}
		setBlendFrames( ANIMCHANNEL_LEGS, 8 );
		playAnim( ANIMCHANNEL_LEGS, "idle" );
		sys.wait( sys.random(2) + 1 );
	}
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 4 );
}

void monster_hunter::Legs_Maneuver() {
	nextManeuver = sys.getTime() + 5;
	scriptDir = HUNTER_S;
	playAnim( ANIMCHANNEL_LEGS, "alert_backup" );
	while( !animDone( ANIMCHANNEL_LEGS, 4 ) ) {
		if ( AI_FORWARD || AI_BLOCKED ) {
			break;
		}
		waitFrame();
	}
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 4 );
}

void monster_hunter::Legs_Fall() {
	playCycle( ANIMCHANNEL_LEGS, "jump_fall" );
	eachFrame {
		if ( !AI_FALLING ) {
			playAnim( ANIMCHANNEL_LEGS, "jump_land" );
			while ( !animDone( ANIMCHANNEL_LEGS, 4 ) ) {
				waitFrame();
			}
			animState( ANIMCHANNEL_LEGS, "Legs_Idle", 4 );
		}
	}
}

void monster_hunter::Legs_Crouch() {
	DisableWalkIK();
	playCycle( ANIMCHANNEL_LEGS, "alert_crouch" );
	eachFrame {
		if ( AI_FORWARD ) {
			animState( ANIMCHANNEL_LEGS, "Legs_Walk", 4 );
		}
	}
}

void monster_hunter::init() {
	entity	entHunterFlashlight;
	sys.setSpawnArg( "light_target", "0 0 -768" );		// light cone direction
	sys.setSpawnArg( "light_up", "-256 0 0" );			// light cone height
	sys.setSpawnArg( "light_right", "0 -256 0" );		// light cone width
   	sys.setSpawnArg( "_color", "1 1 1" );        		// light color
   	sys.setSpawnArg( "texture", "lights/hunterlight" );	// custom light shader
   	entHunterFlashlight = sys.spawn("light");
   	entHunterFlashlight.bindToJoint( self, "fx_barrel", true );
   	entHunterFlashlight.setOrigin( '8 0 0' );
	
	numGrenades = 12;
	elite = getIntKey( "elite" );
	can_snipe = getIntKey( "can_snipe" );
	setState( "state_Begin" );
}

void monster_hunter::state_Begin() {
	flashLightOff();
	animState( ANIMCHANNEL_TORSO, "Torso_Idle", 0 );
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 0 );
	monster_begin();
	setMoveType( MOVETYPE_ANIM );		
	setState( "state_Idle" );
}

void monster_hunter::state_Idle() {
	setAnimPrefix( "" );
	wait_for_enemy();
	if ( getIntKey( "grav_combat" ) || inGravityZone() ) {
		setState( "state_GravCombat" );
	} else if ( AI_WALLWALK ) {
		setState( "state_WallwalkCombat" );
	} else {
		setState( "state_Combat" );
	}
}

void monster_hunter::do_attack( float attack_flags ) {
	if ( !attack_flags ) {
		return;
	}
	if ( AI_VEHICLE ) { 
		if ( attack_flags & ATTACK_SPECIAL1 ) {
			combat_range_vehicle();
		}
	} else if ( attack_flags & ATTACK_MELEE ) {
		combat_melee();
	} else if ( attack_flags & ATTACK_SPECIAL2 ) {
		combat_dodge();
	} else if ( attack_flags & ATTACK_SPECIAL3 ) {
		combat_range();
	} else if ( attack_flags & ATTACK_MISSILE ) {
		if ( enemyRange() > getIntKey( "snipe_range" ) && ( getIntKey( "can_snipe" ) || getIntKey( "force_snipe" ) ) ) {
			sniper = true;
			combat_snipe();
		} else {
			if ( should_grenade() ) {
				combat_grenade();
			} else {
				combat_range();
			}
		}
	}
}

float monster_hunter::check_attacks() {
	float attack_flags;
	float currentTime = sys.getTime();
	if ( AI_VEHICLE ) {
		if ( AI_ENEMY_IN_FOV && currentTime >= nextVehicleAttack ) {
			attack_flags |= ATTACK_SPECIAL1;
		}
		return attack_flags;
	}

	//check for melee attack
	if ( currentTime > nextAttack && AI_ENEMY_VISIBLE && !enemyInVehicle() && enemyRange() < 50 ) { 
		attack_flags |= ATTACK_MELEE;
	}

	//check for indirect damage by shooting things with reactions
	if ( currentTime >= nextDamageReaction ) {
		nextDamageReaction = currentTime + sys.random(2) + 2;
		cur_reaction = findReaction( "DamageEnemy" );
		attack_flags |= ATTACK_SPECIAL1;
	}

	//check for range attack
	if ( ( AI_ENEMY_VISIBLE || ( AI_WALLWALK && AI_ENEMY_VISIBLE ) ) && currentTime >= nextAttack ) {
		attack_flags |= ATTACK_MISSILE;
	} else {
		saySound( "snd_intimidate" );
	}


	if ( elite && !sniper && !AI_WALLWALK && sys.getTime() > nextEliteManeuver && !inGravityZone() ) {
		nextEliteManeuver = sys.getTime() + 5 + sys.random(2);
		if ( testAnimMove( "jump45l" ) || testAnimMove( "jump45r" ) ) {
			attack_flags |= ATTACK_SPECIAL2;
		} else {
			nextManeuver = 0;
		}
	}

	return attack_flags;
}

void monster_hunter::combat_snipe() {
	float end_time,last_seen_time,kick_time,amp;
	vector kick;
	sys.wait( sys.random(0.5) );
	laserOn();
	stopMove();
	end_time = sys.getTime() + 2.0;
	amp = 4;
	startSound( "snd_sniperlaser", SND_CHANNEL_BODY, 0 );	
	faceEnemy();
	eachFrame {
		lookAtEnemy( 1 );
		if ( sys.getTime() > kick_time ) {
			amp -= 0.4;
			if ( amp < 0 ) {
				amp = 0;
			}
			kick_x = amp * (1 - sys.random(2));
			kick_y = amp * (1 - sys.random(2));
			kickAngle( kick );
			kick_time = sys.getTime() + 0.3 + sys.random(0.4);
		}
		//wait until end_time to shoot
		//if enemy is not visible for a while, then exit and try something else
		if ( sys.getTime() > end_time ) {
			animState( ANIMCHANNEL_TORSO, "Torso_Snipe", 4 );
			waitAction( "snipe" );
			nextAttack = sys.getTime() + 3;
			break;
		} else if ( AI_ENEMY_VISIBLE ) {
			last_seen_time = sys.getTime();
		} else if ( sys.getTime() - last_seen_time > 1.0 ) {
			break;
		} else if ( enemyRange() < getIntKey( "snipe_range" ) ) {
			break;
		}
	}
	stopMove();
	laserOff();
}

void monster_hunter::combat_grenade() {
	entity ally = getAlly();
	waitFrame();
	if ( ally ) {
		saySound( "snd_throwing_grenade" );
		sys.wait(0.8);
	}
	stopMove();
	animState( ANIMCHANNEL_TORSO, "Torso_GrenadeAttack", 0 );
	waitAction( "grenade_attack" );
	nextAttack = sys.getTime() + 1.5;
	nextGrenade = sys.getTime() + 10;
}

void monster_hunter::combat_range() {
	entity current_target = getShootTarget();
	if ( !AI_PATHING && current_target == lastShootTarget ) {
		setShootTarget( $null_entity );
		current_target = $null_entity;
	}
	lastShootTarget = current_target;
	laserOff();
	lookAt( current_target, 5 );
	animState( ANIMCHANNEL_TORSO, "Torso_RangeAttack", 4 );
	if ( !elite ) {
		if ( getAlly() ) {
			waitFrame();
			if ( !sayEnemyInfo() ) {
				if ( sys.random(100) < 20 ) {
					saySound( "snd_intimidate" );
				}
			}
		} else if ( sys.random(100) < 20 ) {
			saySound( "snd_intimidate" );
		}
	}
	if ( enemyRange() < 80 && !enemyInVehicle() ) {
		combat_melee();
	}
	float min = getFloatKey( "dda_attack_min" );
	float max = getFloatKey( "dda_attack_max" );
	nextAttack = sys.getTime() + (min + (max-min)*$player1.getDDAValue());
}

void monster_hunter::combat_melee() {
	animState( ANIMCHANNEL_TORSO, "Torso_MeleeAttack", 4 );
	waitAction( "melee_attack" );
	nextAttack = sys.getTime() + 2;
}

boolean monster_hunter::combat_dodge() {
	float dodge_flags;
	if ( testAnimMove( "jump45l" ) ) {
		dodge_flags |= ATTACK_DODGE_LEFT;
	}
	if ( testAnimMove( "jump45r" ) ) {
		dodge_flags |= ATTACK_DODGE_RIGHT;
		if ( dodge_flags & ATTACK_DODGE_LEFT ) {
			if ( sys.random( 100 ) < 50 ) {
				dodge_flags &= ~ATTACK_DODGE_RIGHT;
			} else {
				dodge_flags &= ~ATTACK_DODGE_LEFT;
			}
		}
	}
	lookAt( $null_entity, 0 );
	if ( dodge_flags & ATTACK_DODGE_LEFT ) {
		stopMove();
		faceEnemy();
		startSound( "snd_jump", SND_CHANNEL_VOICE, 0 );
		animState( ANIMCHANNEL_LEGS, "Legs_JumpLeft", 16 );
		waitAction( "dive" );
		setBlendFrames( ANIMCHANNEL_LEGS, 8 );
		lookAtEnemy( 15 );
		return true;
	} else if ( dodge_flags & ATTACK_DODGE_RIGHT ) {
		stopMove();
		faceEnemy();
		startSound( "snd_jump", SND_CHANNEL_VOICE, 0 );
		animState( ANIMCHANNEL_LEGS, "Legs_JumpRight", 16 );
		waitAction( "dive" );
		setBlendFrames( ANIMCHANNEL_LEGS, 8 );
		lookAtEnemy( 15 );
		return true;
	}
	return false;
}

void monster_hunter::combat_portalexit() {
	stopMove();
	if ( enemyRange() < 150 ) {
		sys.wait(0.4);
		combat_melee();
	} else {
		sys.wait(3);
	}
}

void monster_hunter::path_ledge() {
	AI_ALLOW_ORDERS = false;
	AI_DIR_MOVEMENT = false;
	vector ang = current_path.getAngles();
	DisableWalkIK();
	moveToEntity( current_path );
	while( !AI_MOVE_DONE ) {
		waitFrame();
	}
	stopMove();
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 0 );
	turnTo( ang_y );
	while( !facingIdeal() ) {
		waitFrame();
	}
	allowFall( false );
	disableClip();
	sys.wait(0.2);
	playAnim( ANIMCHANNEL_LEGS, current_path.getKey("anim") );
	while( !animDone( ANIMCHANNEL_LEGS, 4 ) ) {
		waitFrame();
	}
	if ( !current_path.getKey( "open_ledge" ) ) {
		sys.wait(0.5);
	}
	enableClip();
	eachFrame {
		if ( AI_ONGROUND ) {
			playAnim( ANIMCHANNEL_LEGS, "jump_land" );
			while( !animDone( ANIMCHANNEL_LEGS, 8 ) ) {
				waitFrame();
			}
			break;
		}
	}
	AI_ALLOW_ORDERS = true;
	AI_DIR_MOVEMENT = true;
	setBlendFrames( ANIMCHANNEL_LEGS, 4 );
}

void monster_hunter::monster_begin() {
	float	teleportType,waittime,movetype;
	string	triggerAnim,portalAnim;
	boolean start_active;
	entity  path,enemy;

	run	= false;
	ignore_sight = getIntKey( "no_sight" );

	if ( !getIntKey( "ignore_flashlight" ) ) {
		// allow waking up from the flashlight
		wakeOnFlashlight( true );
	}

	start_active = false;

	if ( ai_resurrect ) {
		teleportType = 4;
		triggerAnim = "";
		AI_ACTIVATED = true;
	} else {
		teleportType = getIntKey( "teleport" );
		triggerAnim = getKey( "trigger_anim" );
	}

	if ( getIntKey( "spawner" ) ) {
		setState( "state_Spawner" );
	}

	if ( getIntKey( "portal" ) ) {
		//
		// teleport in when triggered
		//
		if ( !isHidden() ) {
			hide();
			waitUntil( AI_ACTIVATED );
		}
		waitUntil( canBecomeSolid() );
		createMonsterPortal();
		becomeSolid();
		flashLightOff();
		wait( 1 ); // cjr - wait one second while the portal opens
		trigger_wakeup_targets();
		show();
		if ( hasAnim( 0, getKey( "portal_anim" ) ) ) {	
			lookAtEnemy(100);
			playCustomAnim( getKey( "portal_anim" ), 0, 4 );
			lookAtEnemy(0);

			if ( getIntKey( "portalCollide" ) ) {
				setPortalCollision( true ); // cjr: monsters that portal in will collide with their own portals instead of going through them
			}
		}
		nextAttack = sys.getTime() + 1.3;
		if ( getEnemy() ) {
			setTurnRate(0);
			sys.wait(0.2);
			flashLightOn();
			if ( !sayEnemyInfo() ) {
				saySound( "snd_sight" );
			}
			lookAtEnemy(100);
			setTurnRate( getIntKey( "turn_rate" ) );
		}
		if ( !getIntKey( "portal_no_fall" ) ) {
			allowFall( true );
		}
		sys.wait(0.7);
		start_active = true;
	} else if(getIntKey("encased") == 1) {
        becomeNonSolid();		
		// sit in our idle anim till we're activated		
		playCustomCycle( getKey( "encased_idle" ), 4 );
		waitUntil( AI_ACTIVATED );        
		show();
		start_active = true;
		trigger_wakeup_targets();
		setOrigin( getOrigin() + getVectorKey( "encased_exit_offset" ) );
		playCustomAnim( getKey( "encased_exit" ), 0, 4 );
		waitAction( "customAnim" );
		becomeSolid();		
	} else if ( triggerAnim != "" ) {
		//
		// hide until triggered and then play a special animation
		//
		checkAnim( ANIMCHANNEL_TORSO, triggerAnim );
		hide();
		waitUntil( AI_ACTIVATED );
		waitUntil( canBecomeSolid() );

		// don't go dormant during trigger_anim anims since they
		// may end up floating in air during no gravity anims.
		setNeverDormant( true );

		show();
		trigger_wakeup_targets();
		playCustomAnim( triggerAnim, 0, 4 );
		waitAction( "customAnim" );
		setNeverDormant( getFloatKey( "neverdormant" ) );
		locateEnemy();
		start_active = true;
	} else if ( teleportType > 0 ) {
		//
		// teleport in when triggered
		//
		hide();
		waitUntil( AI_ACTIVATED );
		waitUntil( canBecomeSolid() );
		becomeSolid();
		movetype = getMoveType();
		setMoveType( MOVETYPE_STATIC );

		// don't go dormant during teleport anims since they
		// may end up floating in air during no gravity anims.
		setNeverDormant( true );

		trigger_wakeup_targets();
		if ( teleportType == 1 ) {
			startFx( getKey( "fx_teleport1" ) );
			wait( 1.6 );
		} else if ( teleportType == 2 ) {
			startFx( getKey( "fx_teleport2" ) );
			wait( 2.6 );
		} else if ( teleportType == 3 ) {
			startFx( getKey( "fx_teleport3" ) );
			wait( 3.6 );
		} else {
			startFx( getKey( "fx_teleport" ) );
			wait( 0.6 );
		}
		show();
		playCustomAnim( "teleport", 0, 4 );
		waitAction( "customAnim" );
		setNeverDormant( getFloatKey( "neverdormant" ) );
		locateEnemy();
		setMoveType( movetype );
		start_active = true;
	} else if ( getIntKey( "hide" ) ) {
		//
		// hide until triggered
		//
		if ( !isHidden() ) {
			hide();
			waitUntil( AI_ACTIVATED );
		}
		if ( ( getIntKey( "hide" ) == 1 ) || ambush ) {
			AI_ACTIVATED = false;
			clearEnemy();
		}
		if ( getIntKey( "start_non_solid" ) ) {
			becomeNonSolid();
			show();
		} else {
			waitUntil( canBecomeSolid() );
			show();
		}
	}

	waittime = getFloatKey( "wait" );
	if ( waittime > 0 ) {
		sys.wait( waittime );
	}

	enemy = getEntityKey( "enemy" );	
	if ( enemy ) {
		setEnemy( enemy );
	}

	if ( !start_active ) {
		if ( getIntKey( "wake_on_attackcone" ) ) {
			wake_on_attackcone();
		} else if ( getIntKey( "walk_on_trigger" ) ) {
			walk_on_trigger();
		} else if ( getIntKey( "trigger" ) ) {
			wake_on_trigger();
		} else {
			wake_on_enemy();
		}
	} else if ( getIntKey( "attack_path" ) ) {
		// follow a path and fight player at end
		path = randomPath();
		if ( path ) {
			run = true;
			ignoreEnemies = true;
			idle_followPathEntities( path );
			ignoreEnemies = false;
		}
	}

	// allow him to see after he's woken up
	ignore_sight = false;

	// ignore the flashlight from now on
	wakeOnFlashlight( false );
}

void monster_hunter::check_dir() {
	if ( !AI_FORWARD ) {
		animState( ANIMCHANNEL_LEGS, "Legs_Idle", 4 );
	}
	if ( AI_DIR_MOVEMENT ) {
		if ( AI_DIR == HUNTER_N ) {
			if( scriptDir != HUNTER_N ) {
				animState( ANIMCHANNEL_LEGS, "Legs_Walk", 4 );
			}
		} else if ( AI_DIR == HUNTER_S ) {
			if( scriptDir != HUNTER_S ) {
				animState( ANIMCHANNEL_LEGS, "Legs_Backup", 4 );
			}
		} else if ( AI_DIR == HUNTER_E ) {
			if( scriptDir != HUNTER_E ) {
				animState( ANIMCHANNEL_LEGS, "Legs_WalkLeft", 4 );
			}	
		} else if ( AI_DIR == HUNTER_W ) {
			if( scriptDir != HUNTER_W ) {
				animState( ANIMCHANNEL_LEGS, "Legs_WalkRight", 4 );
			}
		}
	} else if ( run ) {
		animState( ANIMCHANNEL_LEGS, "Legs_Run", 4 );
	}
	waitFrame();
}

boolean monster_hunter::should_grenade() {
	if ( !getIntKey( "can_grenade" ) ) {
		return false;
	}
	if ( enemyIsA( "hhTalon" ) ) {
		return false;
	}
	float range = enemyRange2D();
	if ( sys.getTime() > nextGrenade && !enemyOnWallwalk() && !enemyInVehicle() && !inGravityZone() && numGrenades > 0 ) {
		if ( range > getFloatKey( "grenade_range" ) && range < 1200 ) {
			return true;
		}
	}
	return false;
}

boolean monster_hunter::use_reaction() {
	boolean bHaveEnemy = false;
	if( getEnemy() ) {
		bHaveEnemy = true;
	}
	eachFrame {
		if ( !getEnemy() ) {
			stopMove();
			wait_for_enemy();
		}
		if ( testMeleeAttack() && !enemyInVehicle() ) {
			combat_melee();
		}
		useReaction();
		if( AI_REACTION_FAILED ) {
			return false;
		}
		else if( !AI_USING_REACTION ) {
			return true;
		}
		if( !bHaveEnemy && !AI_REACTION_ANIM && check_enemies_reaction ) {
			if( checkForEnemy(idle_sight_fov) ) {
				enemy_acquired_reaction();
				return false;
			}
		}
	}
}

vector monster_hunter::find_cover() {
	vector point;
	setKey( "cover_range", "100" );
	point = getCoverNode();
	waitFrame();
	if ( point  == '0 0 0' ) {
		point = getCoverPoint();
	} else {
		printAction( "COVER NODE" );
	}
	waitFrame();
	if ( point == '0 0 0' ) {
		setKey( "cover_range", "200" );
		point = getCoverPoint();
		waitFrame();
	} else {
		printAction( "COVER POINT" );
	}
	if ( point == '0 0 0' ) {
		setKey( "cover_range", "800" );
		point = getCoverPoint();
		waitFrame();
		if ( point = '0 0 0' ) {
			printAction( "COVER POINT" );
		}
	} else {
		printAction( "COVER POINT" );
	}
	return point;
}

boolean monster_hunter::combat_cover() {
	if ( sys.getTime() < nextCover ) {
		return true;
	}
	if ( can_snipe && enemyInVehicle() ) {
		return true;
	}

	//if health is low, move to a healthspore
	if ( sys.random(100) < 60 && sys.getTime() > nextHealCheck && getHealth() < 99 ) {
		waitFrame();
		nextHealCheck = sys.getTime() + 1;
		cur_reaction = findReaction( "heal" );
		sys.wait(0.1);
		if ( cur_reaction ) {
			nextHealCheck = sys.getTime() + 999999;
			saySound( "snd_health" );
			moveToPosition( cur_reaction.getOrigin() );
			nextCover = sys.getTime() + 7;
			nextMove = sys.getTime() + 7;
			nextManeuver = sys.getTime() + 7;
			nextAdjust = sys.getTime() + 7;
			nextCharge = sys.getTime() + 7;
			nextConsole = sys.getTime() + 7;
			sys.wait(0.1);
			return true;
		}
	}

	nextCover = sys.getTime() + 0.5 + sys.random(0.5);
	stopMove();
	lookAtEnemy( 100 );
	AI_NEXT_DIR_TIME = 0;
	AI_DIR_MOVEMENT = true;
	vector point = find_cover();
	waitFrame();
	vector old_point = getOrigin();
    if ( point != '0 0 0' ) {
		moveToPosition( point );
		waitFrame();
		if ( AI_MOVE_DONE ) {
			return false;
		}
		float end_time = sys.getTime() + 15;
		eachFrame {
			if ( AI_LAST_ENEMY_VISIBLE && !AI_ENEMY_VISIBLE && sys.getTime() > nextLean ) {
				if ( enemyRange() > 150 ) {
					sys.wait(0.1);
					if ( last_dir == HUNTER_E ) {
						if ( testAnimMove( "cover_rlean" ) ) {
							animState( ANIMCHANNEL_LEGS, "Legs_LeanRight", 4 );
						}
					} else if ( last_dir == HUNTER_W ) {
						if ( testAnimMove( "cover_llean" ) ) {
							animState( ANIMCHANNEL_LEGS, "Legs_LeanLeft", 4 );
						}
					}
					nextLean = sys.getTime() + 4;
					moveToPosition( point );
					waitFrame();
					sys.wait(2);
				}
			}
			AI_LAST_ENEMY_VISIBLE = AI_ENEMY_VISIBLE;
			//HUMANHEAD jsh PCF 5/2/06 hunter combat fixes
			if ( !getEnemy() ) {
				stopMove();
				wait_for_enemy();
			}
			lookAtEnemy( 1 );
			if ( AI_BLOCKED_FAILSAFE || sys.getTime() > end_time ) {	//reality check
				stopMove();
				break;
			}
			do_attack( check_attacks() );
			if ( AI_MOVE_DONE ) {
				break;
			}
		}
		animState( ANIMCHANNEL_LEGS, "Legs_Crouch", 8 );
		printAction( "COVER WAIT" );
		end_time = sys.getTime() + 1;
		nextCharge = sys.getTime() + 4;
		eachFrame {
			//HUMANHEAD jsh PCF 5/2/06 hunter combat fixes
			if ( !getEnemy() ) {
				stopMove();
				wait_for_enemy();
			}
			if ( AI_ENEMY_VISIBLE || sys.getTime() > end_time || enemyRange() < 100 ) {
				break;
			}
		}
		animState( ANIMCHANNEL_LEGS, "Legs_Idle", 8 );
		if ( AI_ENEMY_REACHABLE ) {
			printAction( "COVER ADVANCE" );
			moveToEnemy();
		} else if ( AI_ENEMY_VISIBLE ) {
			printAction( "COMBAT" );
			return true;
		}
		waitFrame();
		eachFrame {
			//HUMANHEAD jsh PCF 5/2/06 hunter combat fixes
			if ( !getEnemy() ) {
				stopMove();
				wait_for_enemy();
			}
			if ( AI_ENEMY_VISIBLE || AI_MOVE_DONE ) {
				nextCover = sys.getTime() + 1.5;
				stopMove();
				printAction( "COVER FOUND ENEMY" );
				break;
			}
		}
		printAction( "COMBAT" );
		return true;
	}
	return false;
}

void monster_hunter::combat_charge() {
	if ( sys.getTime() < nextCharge ) {
		return;
	}
	stopMove();
	printAction( "CHARGE" );
	lookAtEnemy( 100 );
	AI_NEXT_DIR_TIME = 0;
	AI_DIR_MOVEMENT = true;
	stopMove();
	saySound( "snd_anger" );
	moveToEnemy();
	waitFrame();
	if ( AI_MOVE_DONE ) {
		return;
	}
	float end_time = sys.getTime() + 4;
	eachFrame {
		if ( !getEnemy() ) {
			stopMove();
			wait_for_enemy();
		}
		lookAtEnemy( 1 );
		do_attack( check_attacks() );
		if ( enemyRange() < 100 && !enemyInVehicle() ) {
			combat_melee();
			break;
		}
		if ( AI_MOVE_DONE || sys.getTime() > end_time ) {
			break;
		}
	}
	stopMove();
}

boolean monster_hunter::combat_console() {
	waitFrame();
	stopMove();
	nextConsole = sys.getTime() + 2 + sys.random(1);
	cur_reaction = findReaction( "CallBackup" );
	entity console = cur_reaction;
	if ( cur_reaction ) {
		AI_NEXT_DIR_TIME = 0;
		lookAtEnemy( 100 );
		printAction( "ALARM" );
		float end_time;
		float check_time = sys.getTime() + 10;
		saySound( "snd_alarm" );
		eachFrame {
			if ( !getEnemy() ) {
				stopMove();
				wait_for_enemy();
			}
			do_attack( check_attacks() );
			useReaction();
			if( AI_BLOCKED_FAILSAFE || AI_BLOCKED || AI_REACTION_FAILED ) {
				return false;
			} else if( !AI_USING_REACTION  ) {
				break;
			}
		}
		animState( ANIMCHANNEL_TORSO, "Torso_Idle", 4 );
		stopMove();
		if ( distanceTo( console ) > 200 ) {
			animState( ANIMCHANNEL_TORSO, "Torso_Idle", 4 );
			lookAtEnemy( 100 );
			printAction( "ALARM DONE" );
			return false;
		}
		printAction( "Turning to alarm" );
		lookAt( $null_entity, 0 );
		vector ang = sys.VecToAngles( console.getOrigin() - getOrigin() );
		turnTo( ang_y );
		end_time = sys.getTime() + 2;
		while ( sys.getTime() < end_time ) {
			if ( facingIdeal() ) {
				break;
			}
			waitFrame();
		}
		printAction( "Playing alarm anim" );
		animState( ANIMCHANNEL_LEGS, "Legs_Idle", 4 );
		playAnim( ANIMCHANNEL_TORSO, "console_use" );
		end_time = sys.getTime() + 0.6;
		while ( !animDone( ANIMCHANNEL_TORSO, 4 ) ) {
			if ( sys.getTime() > end_time ) {
				break;
			}
			waitFrame();
		}
		printAction( "Actual alarm on" );
		useConsole( console );
		animState( ANIMCHANNEL_TORSO, "Torso_Idle", 4 );
		lookAtEnemy( 100 );
		printAction( "ALARM DONE" );
		combat_charge();
	}
}

boolean monster_hunter::combat_move() {
	if ( !AI_MOVE_DONE || sys.getTime() < nextAdjust ) {
		return true;
	}
	if ( can_snipe && enemyInVehicle() ) {
		return true;
	}
	waitFrame();
	stopMove();
	nextAdjust = sys.getTime() + 1;
	entity enemy;
	AI_NEXT_DIR_TIME = 0;

	vector point = getSightNode();
	waitFrame();
	if ( point == '0 0 0' ) {
		point = getNearSightPoint();
		waitFrame();
		if ( point == '0 0 0' ) {
			setKey( "attack_range", "400" );
			point = getNearSightPoint();
			waitFrame();
		}
	}
	if ( point != '0 0 0' ) {
		stopMove();
		allowMovement( true );
		lookAtEnemy( 100 );
		AI_DIR_MOVEMENT = true;
		printAction( "MOVE " + point );
		nextAdjust = sys.getTime() + 3;
		moveToPosition( point );
		waitFrame();
		return true;
	}
	return false;
}

void monster_hunter::combat_mandown( entity old_ally ) {
	if ( sniper ) {
		return;
	}
	animState( ANIMCHANNEL_TORSO, "Torso_Idle", 4 );
	stopMove();
	sys.wait(0.3);
	printAction( "MANDOWN" );
	if ( distanceTo( old_ally ) > 100 ) {
		lookAt( old_ally, 1.0 );
	}
	if ( getKey( "backup" ) != "" ) {
		saySound( "snd_backup" );
	} else {
		if ( sys.random(100) < 25 ) {
			saySound( "snd_last_man" );
		} else {
			saySound( "snd_man_down" );
		}
	}
	sys.wait(0.4);
	lookAtEnemy( 10 );
	sys.wait(0.1);
	if ( enemyRange() > 300 ) {
		animState( ANIMCHANNEL_LEGS, "Legs_Crouch", 4 );
	}
	if ( should_grenade() ) {
		combat_grenade();
	}
	sys.wait( 0.4 );
	callBackup( 1.0 );
}

void monster_hunter::state_PortalAttack() {
	entity enemy_portal = getEnemyPortal();
	if ( !enemy_portal ) {
		sys.wait( 0.3 );
		setState( "state_Combat" );
	}
	float end_time;
	vector offset = sys.angToForward( enemy_portal.getAngles() );
	vector pos = enemy_portal.getOrigin() + offset * 150;
	if ( canReachPosition( pos ) ) {
		while ( !AI_ENEMY_VISIBLE ) {
			nextLean = sys.getTime() + 999999;
			nextManeuver = sys.getTime() + 99999;
			nextEliteManeuver = sys.getTime() + 99999;
			AI_DIR_MOVEMENT = false;
			stopMove();
			animState( ANIMCHANNEL_LEGS, "Legs_Idle", 4 );
			moveToPosition( pos );
			end_time = sys.getTime() + 15;
			while ( !AI_MOVE_DONE ) {
				if ( AI_ENEMY_VISIBLE || sys.getTime() > end_time ) {
					lookAtEnemy( 100 );
					sys.wait(0.3);
					setState( "state_Combat" );
				}
				waitFrame();
			}
			turnToEntity( enemy_portal );
			lookAt( enemy_portal, 999 );
			portal_attack = true;
			combat_range();
			end_time = sys.getTime() + 2;
			eachFrame {
				//HUMANHEAD jsh PCF 5/2/06 hunter combat fixes
				if ( !getEnemy() ) {
					stopMove();
					wait_for_enemy();
				}
				if ( AI_ENEMY_VISIBLE || sys.getTime() > end_time ) {
					break;
				}
			}
		}
	}
	lookAtEnemy( 100 );
	sys.wait(0.3);
	setState( "state_Combat" );
}

void monster_hunter::state_TalonCombat() {
	AI_DIR_MOVEMENT = false;
	portal_attack = false;
	stopMove();
	waitFrame();
	setAnimPrefix( "alert" );
	nextEliteManeuver = sys.getTime() + 9999;
	nextGrenade = sys.getTime() + 9999;
	printAction( "COMBAT" );
	waitFrame();
	animState( ANIMCHANNEL_TORSO, "Torso_Idle", 4 );
	turnToEntity( getEnemy() );
	faceEnemy();
	nextAttack = 0;
	eachFrame {
		if( !enemyIsA("hhTalon") ) {
			sys.wait(0.1);
			setState( "state_Combat" );
		}
		lookAt( $null_entity, 0 );
		if ( sys.getTime() > nextSpiritCheck && enemyInSpirit() ) {
			nextSpiritCheck = sys.getTime() + 0.5;
			entity enemy = findEnemyAI( false );
			if ( enemy ) {
				setEnemy( enemy );
			}
		}
		if ( AI_MOVE_DONE ) {
			faceEnemy();
		}
		if ( AI_WALLWALK ) {
			waitFrame();
			setState( "state_WallwalkCombat" );
		}
		if ( !getEnemy() ) {
			stopMove();
			wait_for_enemy();
		}
		if ( sys.getTime() > nextAttack ) {
			if ( enemyRange2D() > 100 ) { 
				animState( ANIMCHANNEL_TORSO, "Torso_QuickShot", 4 );
				sys.wait(0.4);
			} else {
				combat_melee();
			}
			nextAttack = sys.getTime() + 1;
		}
	}
}

void monster_hunter::state_Combat() {
	sys.wait( getFloatKey( "combat_delay" ) );
	beenInCombat = true;	//HUMANHEAD jsh PCF 5/2/06 hunter combat fixes
	AI_DIR_MOVEMENT = true;
	portal_attack = false;
	stopMove();
	entity ally = getAlly();
	waitFrame();
	setAnimPrefix( "alert" );
	nextEliteManeuver = sys.getTime() + 2 + sys.random(4);
	if ( sys.random( 100 ) < 50 ) {
		nextGrenade = sys.getTime() + 3 + sys.random(3);
	} else {
		nextGrenade = sys.getTime() + 10;
	}
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 4 );
	printAction( "COMBAT" );
	combat_console();
	waitFrame();
	if ( enemyInVehicle() ) {
		combat_vehicle();
	}
	waitFrame();
	if ( !combat_cover() ) {
		if ( sys.getTime() > nextManeuver && enemyAimingAtMe() && !inGravityZone() ) {
			if ( !inAnimState( ANIMCHANNEL_LEGS, "Legs_Maneuver" ) ) {
				animState( ANIMCHANNEL_LEGS, "Legs_Maneuver", 4 );
			}
		}
	}
	waitFrame();
	boolean not_doing_so_well;
	lookAtEnemy( 100 );
	entity prev_enemy = getEnemy();
	eachFrame {
		if ( sys.getTime() > nextSpiritCheck && enemyInSpirit() ) {
			nextSpiritCheck = sys.getTime() + 0.5;
			entity enemy = findEnemyAI( false );
			if ( enemy ) {
				setEnemy( enemy );
			}
		}
		if ( AI_MOVE_DONE ) {
			faceEnemy();
		}
		if ( AI_WALLWALK ) {
			waitFrame();
			setState( "state_WallwalkCombat" );
		}
		if ( !getEnemy() ) {
			stopMove();
			wait_for_enemy();
		}
		if ( ally ) {
			if ( ally.getHealth() <= 0 ) {
				ally = $null_entity;
				if ( !elite ) {
					combat_mandown( ally );
				}
			}
		}
		if ( !beenBound ) {
			if ( sys.getTime() > nextConsole ) {
				combat_console();
			}
			waitFrame();
			if ( !not_doing_so_well && getHealth() < 60 ) {
				stopSound( SND_CHANNEL_ANY, 0 );
				saySound( "snd_help" );
				if ( AI_KNOCKBACK || sys.random(100) < 20 ) {
					animState( ANIMCHANNEL_LEGS, "Legs_Knockback", 2 );
					waitAction( "knockback" );
				}
				not_doing_so_well = true;
				if ( !combat_cover() && sys.getTime() > nextManeuver && !inAnimState( ANIMCHANNEL_LEGS, "Legs_Maneuver" ) ) {
					animState( ANIMCHANNEL_LEGS, "Legs_Maneuver", 4 );
				}
				printAction( "COMBAT" );
			}
			waitFrame();
			if ( !AI_ENEMY_VISIBLE && sys.getTime() - AI_ENEMY_LAST_SEEN > 2 ) {
				combat_move();
				nextMove = sys.getTime() + 5;
			}
			waitFrame();
			if ( ( AI_MOVE_DONE && sys.getTime() > nextMove ) || ( AI_LAST_DAMAGE_TIME > 0 && sys.getTime() - AI_LAST_DAMAGE_TIME < 1 ) ) {
				nextMove = sys.getTime() + 2;
				saySound ( "snd_taking_fire" );
				if ( !combat_cover() && sys.getTime() > nextManeuver ) {
					animState( ANIMCHANNEL_LEGS, "Legs_Maneuver", 4 );
				}
				printAction( "COMBAT" );
			}
		}
		waitFrame();
		do_attack( check_attacks() );
	}
}

void monster_hunter::combat_vehicle() {
	if ( !getIntKey( "CanPilotShuttle" ) ) {
		return;
	}
	boolean bHaveEnemy;
	//find vehicle dock
	cur_reaction = findReaction( "VehicleDock" );
	allowFall( false );
	ignoreEnemies = false;
	if ( !cur_reaction ) {
		return;
	}
	if( getEnemy() ) {
		bHaveEnemy = true;
	}
	stopMove();
	AI_NEXT_DIR_TIME = 0;
	AI_DIR_MOVEMENT = false;
	lookAt( $null_entity, 0 );
	run = true;
	eachFrame {
		if ( !enemyInVehicle() || enemyVehicleDocked() ) {
			stopMove();
			run = false;
			return;
		}
		useReaction();
		if( AI_REACTION_FAILED ) {
			stopMove();
			run = false;
			return;
		}
		else if( !AI_USING_REACTION ) {
			stopMove();
			run = false;
			break;
		}
		if( !bHaveEnemy && !AI_REACTION_ANIM && check_enemies_reaction ) {
			if( checkForEnemy(idle_sight_fov) ) {
				enemy_acquired_reaction();
				break;
			}
		}
	}
	//use vehicle
	stopMove();
	run = false;
	cur_reaction = findReaction( "Vehicle" );
	if ( !cur_reaction ) {
		return;
	}
	//wait for dock to create vehicle
	sys.wait(0.6);
	eachFrame {
		useReaction();
		if( AI_REACTION_FAILED ) {
			return;
		} else if( !AI_USING_REACTION  ) {
			break;
		}
	}
	if ( !getVehicle() ) {
		return;
	}
	lookAt( $null_entity, 0 );
	setMoveType( MOVETYPE_FLY );
	flashLightOff();
	nextAttack = 0;
	float end_time;
	setKey( "attack_z", "200" );
	eachFrame {
		vector attack_point = getAttackPoint();
		if ( attack_point != '0 0 0' ) {
			moveToPosition( attack_point );
			end_time = sys.getTime() + 10;
			while ( !AI_MOVE_DONE ) {
				if ( !getEnemy() ) {
					stopMove();
					wait_for_enemy();
				}
				if ( sys.getTime() > end_time ) {
					stopMove();
					break;
				}
				waitFrame();
			}
		} else {
			moveToEnemy();
			sys.wait(2);
		}
		end_time = sys.getTime() + getFloatKey( "shuttle_attack_length" );
		AI_VEHICLE_ATTACK = true;
		while ( sys.getTime() < end_time ) {
			if ( !getEnemy() ) {
				AI_VEHICLE_ATTACK = false;
				stopMove();
				wait_for_enemy();
			}
			faceEnemy();
			waitFrame();
		}
		AI_VEHICLE_ATTACK = false;
	}
}

void monster_hunter::state_Vehicle() {
	combat_vehicle();
	setState( "state_Combat" );
}

void monster_hunter::state_VehicleCombat() {
	flashLightOff();
	wait_for_enemy();
	lookAt( $null_entity, 0 );
	setMoveType( MOVETYPE_FLY );
	eachFrame {
		if ( !getEnemy() ) {
			stopMove();
			wait_for_enemy();
		}
		faceEnemy();
		combat_chase();
	}
	setState( "state_Combat" );
}

void monster_hunter::state_PortalExit() {
	AI_DIR_MOVEMENT = true;
	float end_time = sys.getTime() + 1.5;
	stopMove();
	lookAt( $null_entity, 0 );
	overrideAnim( ANIMCHANNEL_LEGS );
	playAnim( ANIMCHANNEL_LEGS, "openportal" );
	while ( sys.getTime() < end_time ) {
		waitFrame();
	}
	playAnim( ANIMCHANNEL_LEGS, "portalexit" );
	sys.wait(5);
	remove();
}

void monster_hunter::state_DodgeLeft() {
	sys.wait(sys.random(0.1) + 0.05);
	stopMove();
	faceEnemy();
	if ( sys.random(100) < 75 ) {
		startSound( "snd_dodge", SND_CHANNEL_VOICE, 0 );
	}
	animState( ANIMCHANNEL_LEGS, "Legs_DiveLeft", 8 );
	waitAction( "dive" );
	setState( "state_Combat" );
} 

void monster_hunter::state_DodgeRight() {
	sys.wait(sys.random(0.1) + 0.05);
	stopMove();
	faceEnemy();
	if ( sys.random(100) < 75 ) {
		startSound( "snd_dodge", SND_CHANNEL_VOICE, 0 );
	}
	animState( ANIMCHANNEL_LEGS, "Legs_DiveRight", 8 );
	waitAction( "dive" );
	setState( "state_Combat" );
}

void monster_hunter::state_GravCombat() {
	AI_DIR_MOVEMENT = false;
	setAnimPrefix( "alert" );
	run = false;
	float nextTime = sys.getTime() + 2;
	animState( ANIMCHANNEL_LEGS, "Legs_GravWander", 4 );
	lookAtEnemy( 99999 );
	eachFrame {
		EnableWalkIK();
		if ( sys.getTime() > nextSpiritCheck && enemyInSpirit() ) {
			nextSpiritCheck = sys.getTime() + 0.5;
			entity enemy = findEnemyAI( false );
			if ( enemy ) {
				setEnemy( enemy );
			}
		}
		if ( !getEnemy() ) {
			stopMove();
			wait_for_enemy();
		}
		faceEnemy();
		do_attack( check_attacks() );
	}
}

void monster_hunter::state_WallwalkCombat() {
	AI_DIR_MOVEMENT = false;
	float attack_flags;
	setAnimPrefix( "alert" );
	run = false;
	lookAtEnemy( 99999 );
	eachFrame {
		if ( sys.getTime() > nextSpiritCheck && enemyInSpirit() ) {
			nextSpiritCheck = sys.getTime() + 0.5;
			entity enemy = findEnemyAI( false );
			if ( enemy ) {
				setEnemy( enemy );
			}
		}
		if ( !getEnemy() ) {
			stopMove();
			wait_for_enemy();
		}
		if ( !AI_WALLWALK ) {
			sys.wait(0.2);
			setState( "state_Combat" );
		}
		faceEnemy();
		do_attack( check_attacks() );
	}
}

void monster_hunter::combat_range_vehicle() {
	float end_time;
	end_time = sys.getTime() + getFloatKey( "shuttle_attack_length" );
	AI_VEHICLE_ATTACK = true;
	while ( sys.getTime() < end_time ) {
		waitFrame();
	}
	AI_VEHICLE_ATTACK = false;
	if ( enemyInVehicle() ) {
		nextVehicleAttack = sys.getTime() + getFloatKey( "shuttle_attack_freq" ) + sys.random(0.4);
	} else {
		nextVehicleAttack = sys.getTime() + getFloatKey( "shuttle_attack_freq" ) * 2.0 + sys.random(1);
	}
}

void monster_hunter::sight_enemy() {
	string animname;
	vector ang1,ang2,ang3,offset;
	float end_time;
	float dist = distanceTo( getEnemy() );
	stopMove();
	ang1 = sys.VecToAngles( getEnemyPos() - getOrigin() );
	ang2 = getAngles();
	ang3 = anglemod180( ang1 - ang2 );
	setAnimPrefix( "alert" );
	if ( abs(ang3_y) > 160 ) {
		setAnimPrefix( "" );
		sys.wait(0.2);
		lookAtEnemy(1);
		sys.wait(0.3);
		lookAtEnemy(0);
		sys.wait(0.1);
	} else if ( abs(ang3_y) > 25 && dist < 600 ) {
		setTurnRate( 200 );
		sys.wait(0.08);
		lookAtEnemy(999);
		end_time = sys.getTime() + 0.6;
		while ( sys.getTime() < end_time ) {
			if ( AI_PAIN ) {
				break;
			}
			waitFrame();
		}
		setAnimPrefix( "alert" );
		animState( ANIMCHANNEL_TORSO, "Torso_Idle", 4 );
		animState( ANIMCHANNEL_LEGS, "Legs_Backup", 4 );
		sys.wait( 0.04 );
		setTurnRate( 1000 );
		faceEnemy();
		sys.wait( 0.06 );
		setBlendFrames( ANIMCHANNEL_LEGS, 16 );
		animState( ANIMCHANNEL_LEGS, "Legs_Idle", 4 );
	} else if ( dist > 600 ) {
		sys.wait(0.9);
	}
	entity ally = getAlly();
	waitFrame();
	if ( ally ) {
		if ( !sayEnemyInfo() ) {
			saySound( "snd_sight" );
		}
	} else {
		saySound( "snd_sight" );
	}
	flashLightOn();
	animname = self.getKey( "on_activate" );
	if ( animname != "" ) {
		// don't go dormant during on_activate anims since they
		// may end up floating in air during no gravity anims.
		setNeverDormant( true );
		if ( getIntKey( "walk_on_sight" ) ) {
			moveToEnemy();
		}
		animState( ANIMCHANNEL_TORSO, "Torso_Sight", 4 );
		waitAction( "sight" );
		setNeverDormant( getFloatKey( "neverdormant" ) );
	}
}

void monster_hunter::state_FollowAlternatePath() {
	AI_DIR_MOVEMENT = false;
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 4 );
	allowMovement( true );	//HUMANHEAD	for when triggered from wake_on_enemy state
	if ( inAnimState( ANIMCHANNEL_TORSO, "Torso_CustomCycle" ) || inAnimState( ANIMCHANNEL_TORSO, "Torso_CustomAnim" ) ) {
		animState( ANIMCHANNEL_TORSO, "Torso_Idle", 8 );
	}

	ignoreEnemies = true;
	idle_followPathEntities( current_path );
	ignoreEnemies = false;
	setState( "state_Idle" );
}

void monster_hunter::path_shootat() {
	entity current_target = sys.getEntity( current_path.getKey( "shoot_target" ) );
	if ( current_target ) {
		AI_ACTIVATED = false;
		while( !AI_ACTIVATED ) {
			setShootTarget( current_target );
			combat_range();
			sys.wait(1.0);
			waitFrame();
		}
		lookAt( $null_entity, 0 );
	}
}

//HUMANHEAD jsh PCF 5/2/06 hunter combat fixes
boolean	monster_hunter::checkForEnemy( float use_fov ) {
	entity enemy;
	vector size;
	float dist;

	if ( sys.influenceActive() ) {
		return false;
	}

	//HUMANHEAD jsh PCF 5/2/06 hunter combat fixes
	if ( beenInCombat ) {
		use_fov = false;
	}
	//END HUMANHEAD

	if ( AI_PAIN ) {
		// get out of ambush mode when shot
		ambush = false;
	}

	if ( ignoreEnemies ) {
		// while we're following paths, we only respond to enemies on pain, or when close enough to them
		if ( stay_on_attackpath ) {
			// don't exit attack_path when close to enemy
			return false;
		}

		enemy = getEnemy();
		if ( !enemy ) {
			enemy = findEnemy( false );
		}
	
		if ( !enemy ) {
			return false;
		}

		size = getSize();
		dist = ( size_x * 1.414 ) + 16;  // diagonal distance plus 16 units
		if ( enemyRange() > dist ) {
			return false;
		}
	} else {
		if ( getEnemy() ) {
			// we were probably triggered (which sets our enemy)
			return true;
		}

		if ( !ignore_sight ) {
			//HUMANHEAD jsh try to find enemy AI first
			enemy = findEnemyAI( use_fov );

			//havent found enemy AI so look for enemy players now
			if ( !enemy ) {
				enemy = findEnemy( use_fov );
			}
			//enemy = findEnemy( use_fov );
			//END HUMANHEAD
		}
		
		if ( !enemy ) {
			if ( ambush ) {
				return false;
			}

			enemy = heardSound( true );
			if ( !enemy ) {
				return false;
			}
		}
	}

	ignoreEnemies = false;

	// once we've woken up, get out of ambush mode
	ambush = false;
		
	// don't use the fov for sight anymore
	idle_sight_fov = false;

	setEnemy( enemy );
	return true;
}
//END HUMANHEAD

/*
=====================
monster_hunter::state_Killed
=====================
*/
void monster_hunter::state_Killed() {
	stopMove();
	self.removeBinds();

	animState( ANIMCHANNEL_TORSO, "Torso_Death", 0 );
	animState( ANIMCHANNEL_LEGS, "Legs_Death", 0 );

	waitAction( "dead" );
	setState( "state_Dead" );
}